
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Atmosphere Arcade ‚Äî Balloon & Cabin Interactive</title>
<style>
  :root{
    --bg:#0b1020; --ink:#e5ecff; --muted:#96a2c7; --accent:#58b7ff; --good:#22c55e; --bad:#ef4444; --warn:#f59e0b;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  h1{font-size:clamp(1.3rem,2.4vw,2rem);margin:.2rem 0 .4rem}
  .lead{color:var(--muted);margin:0 0 .6rem}
  .topbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0}
  .btn{appearance:none;border:1px solid #2a365a;background:#0f1a36;color:var(--ink);border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn.primary{border-color:var(--accent);box-shadow:0 0 0 2px color-mix(in oklab, var(--accent) 30%, transparent)}
  .hud{display:flex;gap:10px;flex-wrap:wrap;margin:.5rem 0}
  .pill{border:1px solid #2a365a;background:#0f1a36;border-radius:999px;padding:6px 10px}
  .good{color:var(--good)} .bad{color:var(--bad)} .warn{color:var(--warn)}
  .canvas-wrap{position:relative;border:1px solid #243155;border-radius:12px;overflow:hidden}
  canvas{display:block;width:100%;height:auto;background:linear-gradient(#79a6ff,#0a2a78)}
  .help{color:var(--muted);font-size:.95rem;margin:.4rem 0}
  details{margin-top:.6rem}
  summary{cursor:pointer}
  kbd{background:#0f1a36;border:1px solid #2a365a;border-bottom-width:3px;border-radius:6px;padding:1px 5px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Atmosphere Arcade ‚Äî Balloon & Cabin Interactive</h1>
    <p class="lead">Real‚Äëtime controls, physics‚Äëlite models, scoring, and hazards. Use a keyboard/mouse (or touch). Fits inside a Canvas iframe or runs stand‚Äëalone.</p>
  </header>

  <div class="topbar" role="toolbar" aria-label="Game Modes">
    <button class="btn primary" id="modeBalloon">üéà Balloon Ascent</button>
    <button class="btn" id="modeCabin">‚úàÔ∏è Cabin Controller</button>
    <button class="btn" id="btnPause">‚è∏Ô∏è Pause</button>
    <button class="btn" id="btnReset">üîÑ Reset</button>
  </div>

  <div class="hud" id="hud"></div>

  <div class="canvas-wrap">
    <canvas id="game" width="1000" height="580" aria-label="Atmosphere Arcade Game Canvas"></canvas>
  </div>

  <p class="help"><strong>Controls:</strong> 
    <span id="controlsBalloon">
      Balloon ‚Äî Press <kbd>Space</kbd> to heat (burner), hold <kbd>‚Üë</kbd>/<kbd>‚Üì</kbd> to trim altitude, 
      <kbd>‚Üê</kbd>/<kbd>‚Üí</kbd> to steer. 
      Click & drag the balloon to nudge it. Avoid storm clouds ‚ùó Collect research tokens ‚≠ê
    </span>
    <span id="controlsCabin" style="display:none">
      Cabin ‚Äî <kbd>‚Üë</kbd>/<kbd>‚Üì</kbd> change aircraft altitude, <kbd>Q</kbd>/<kbd>E</kbd> rotate the cabin pressure dial, 
      <kbd>W</kbd>/<kbd>S</kbd> fine‚Äëtune. Keep passengers comfy and ŒîP within limits.
    </span>
  </p>

  <details>
    <summary>Teacher notes & model</summary>
    <ul>
      <li>Outside pressure uses an exponential model: <code>P = P0 ¬∑ e^(‚àíalt/H)</code> with <code>P0=101.3 kPa</code>, <code>H=8.5 km</code> (conceptual only).</li>
      <li>Balloon size scales with <code>(P0/P_out)^(1/3)</code> times a heat factor (Space to heat). Popping occurs over a threshold size.</li>
      <li>Cabin controller computes inside pressure from an ‚Äúequivalent cabin altitude‚Äù dial and monitors ŒîP (kPa & psi) vs. comfort/structural bands.</li>
    </ul>
  </details>
</div>

<script>
(function(){
  // ---------- Helpers ----------
  const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // Atmosphere model (toy): kPa
  function pKPa(altKm){ const P0=101.325, H=8.5; return P0*Math.exp(-altKm/H); }

  // ---------- Canvas ----------
  const cvs=document.getElementById('game');
  const ctx=cvs.getContext('2d');
  let W=cvs.width, H=cvs.height;
  function resize(){
    // keep aspect ratio ~ 1000x580; scale via CSS, so canvas resolution stays crisp
  }
  window.addEventListener('resize', resize);

  // ---------- UI elements ----------
  const hud=document.getElementById('hud');
  const btnBalloon=document.getElementById('modeBalloon');
  const btnCabin=document.getElementById('modeCabin');
  const btnPause=document.getElementById('btnPause');
  const btnReset=document.getElementById('btnReset');
  const controlsBalloon=document.getElementById('controlsBalloon');
  const controlsCabin=document.getElementById('controlsCabin');

  let paused=false;
  btnPause.onclick=()=>{paused=!paused; btnPause.textContent=paused? '‚ñ∂Ô∏è Resume':'‚è∏Ô∏è Pause'};

  // ---------- Input ----------
  const keys={};
  window.addEventListener('keydown',e=>{keys[e.key.toLowerCase()]=true;});
  window.addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});

  // Pointer/drag
  let pointer={x:0,y:0,down:false};
  cvs.addEventListener('pointerdown',e=>{pointer.down=true; const r=cvs.getBoundingClientRect(); pointer.x=e.clientX-r.left; pointer.y=e.clientY-r.top;});
  cvs.addEventListener('pointerup',()=>{pointer.down=false;});
  cvs.addEventListener('pointermove',e=>{const r=cvs.getBoundingClientRect(); pointer.x=e.clientX-r.left; pointer.y=e.clientY-r.top;});

  // ---------- Modes ----------
  const MODE={BALLOON:0,CABIN:1};
  let mode=MODE.BALLOON;
  btnBalloon.onclick=()=>switchMode(MODE.BALLOON);
  btnCabin.onclick=()=>switchMode(MODE.CABIN);

  function switchMode(m){ mode=m; reset();
    if(mode===MODE.BALLOON){
      btnBalloon.classList.add('primary'); btnCabin.classList.remove('primary');
      controlsBalloon.style.display='inline'; controlsCabin.style.display='none';
    } else {
      btnCabin.classList.add('primary'); btnBalloon.classList.remove('primary');
      controlsCabin.style.display='inline'; controlsBalloon.style.display='none';
    }
  }

  btnReset.onclick=()=>reset();

  // ---------- Balloon Game State ----------
  let b;
  let clouds=[]; // hazards
  let tokens=[]; // stars at target altitudes
  let score=0; let lives=1; let time=0;

  function initBalloon(){
    b={x:W*0.5,y:H-90,vx:0,vy:0,altKm:0,heat:0,sizeRatio:1,popped:false};
    // spawn clouds (hazards) and tokens
    clouds=[]; tokens=[]; score=0; lives=1; time=0;
    for(let i=0;i<6;i++){
      const cx=Math.random()*W, cy=lerp(H-120,80,Math.random());
      const r=lerp(30,70,Math.random()); const vx=lerp(-0.4,0.4,Math.random());
      const cold=Math.random()<0.55; // some clouds are cold (heat drain)
      clouds.push({x:cx,y:cy,r, vx, cold});
    }
    // tokens at approximate altitudes (2, 5, 8 km) mapped to canvas y
    const alts=[2,5,8];
    for(const a of alts){
      const y=altToY(a);
      tokens.push({x:lerp(120,W-120,Math.random()), y, r:16, got:false, alt:a});
    }
  }

  function altToY(altKm){ // 0 km ~ ground (H-64), 10 km ~ y~60
    return lerp(H-90, 70, clamp(altKm/10,0,1));
  }

  // ---------- Cabin Game State ----------
  let plane;
  function initCabin(){
    plane={x:120,y:H*0.55,altKm:9.5,vy:0, cabinEqKm:2.4, timeSafe:0, timeUnsafe:0};
  }

  function reset(){
    if(mode===MODE.BALLOON) initBalloon(); else initCabin();
  }
  reset();

  // ---------- Draw helpers ----------
  function drawSkyGradient(){
    const g=ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#78a7ff'); g.addColorStop(1,'#0b1f61');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  }
  function drawGround(){
    ctx.fillStyle='#0c3c2b'; ctx.fillRect(0,H-64,W,64);
  }
  function drawCloud(c){
    ctx.save(); ctx.translate(c.x,c.y);
    ctx.fillStyle=c.cold? 'rgba(180,220,255,0.9)':'rgba(255,255,255,0.9)';
    for(let i=0;i<4;i++){
      const ox=(i-1.5)*c.r*0.8, oy= (i%2? -1:1)*c.r*0.2;
      ctx.beginPath(); ctx.arc(ox,oy,c.r*0.7,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
  function drawStar(t){
    ctx.save(); ctx.translate(t.x,t.y); ctx.rotate(time*0.002);
    ctx.fillStyle=t.got? 'rgba(255,223,99,0.4)':'#ffd84a';
    starPath(ctx, t.r); ctx.fill();
    ctx.restore();
  }
  function starPath(ctx, r){
    ctx.beginPath();
    for(let i=0;i<5;i++){
      const a=(i*72-90)*Math.PI/180; const ax=Math.cos(a)*r, ay=Math.sin(a)*r;
      const b=(i*72-90+36)*Math.PI/180; const bx=Math.cos(b)*r*0.45, by=Math.sin(b)*r*0.45;
      if(i===0) ctx.moveTo(ax,ay); else ctx.lineTo(ax,ay); ctx.lineTo(bx,by);
    }
    ctx.closePath();
  }

  // ---------- HUD ----------
  function setHUD(items){
    hud.innerHTML='';
    for(const it of items){
      const d=document.createElement('div'); d.className='pill'; d.innerHTML=it; hud.appendChild(d);
    }
  }

  // ---------- Game loop ----------
  let last=performance.now();
  function frame(now){
    requestAnimationFrame(frame);
    const dt=Math.min(0.05,(now-last)/1000); last=now; if(paused) return;

    if(mode===MODE.BALLOON) tickBalloon(dt); else tickCabin(dt);
  }
  requestAnimationFrame(frame);

  // ---------- Balloon tick ----------
  function tickBalloon(dt){
    time+=dt;
    // Controls
    const thrust=(keys[' ']? 40:0); // burner adds heat
    if(keys['arrowup']) b.vy-=15*dt; if(keys['arrowdown']) b.vy+=15*dt;
    if(keys['arrowleft']) b.vx-=15*dt; if(keys['arrowright']) b.vx+=15*dt;
    // Heat dynamics
    b.heat += (keys[' ']? 0.9:-0.3)*dt; b.heat=clamp(b.heat,0,1.2);

    // Drag nudge if pointer near balloon
    const dx=pointer.x-b.x, dy=pointer.y-b.y; const dist=Math.hypot(dx,dy);
    const isOver = dist < 60 && pointer.down; if(isOver){ b.vx+=dx*0.002; b.vy+=dy*0.002; }

    // Simple wind by altitude
    const wind=lerp(-12,12, (b.y/H)); // stronger variable wind with height
    b.vx += wind*0.03*dt;

    // Integrate motion
    b.vx*=0.995; b.vy*=0.995; // damping
    b.x += b.vx; b.y += b.vy;

    // Altitude based on y (invert): map y to altKm
    // inverse of altToY; linear approx within range
    const t=clamp((b.y-70)/(H-160),0,1); b.altKm= (1-t)*10; // 0..10 km

    // Outside pressure & size
    const Pout=pKPa(b.altKm);
    const size=(Math.pow(101.325/Pout,1/3))*(1+0.35*b.heat);
    b.sizeRatio=size; if(size>2.15){ b.popped=true; lives=0; }

    // Collisions with clouds
    for(const c of clouds){
      c.x += c.vx; if(c.x<-120) c.x=W+120; if(c.x>W+120) c.x=-120;
      const dd=Math.hypot(b.x-c.x,b.y-c.y);
      if(dd < 60+c.r*0.6){ // overlap
        if(c.cold) b.heat = Math.max(0, b.heat-0.6*dt);
        // turbulence
        b.vx += (Math.random()-0.5)*20*dt; b.vy += (Math.random()-0.5)*20*dt;
      }
    }

    // Token collection
    for(const tkn of tokens){
      if(!tkn.got && Math.hypot(b.x-tkn.x,b.y-tkn.y)<40){ tkn.got=true; score+=100; }
    }

    // Bounds
    b.x=clamp(b.x,40,W-40); b.y=clamp(b.y,60,H-90);

    // Draw
    drawSkyGradient(); drawGround();
    // Alt grid
    ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1;
    for(let a=0;a<=10;a+=2){ const yy=altToY(a); ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(W,yy); ctx.stroke(); ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.fillText(a+" km", 6, yy-4); }

    // Clouds
    for(const c of clouds) drawCloud(c);

    // Balloon
    if(!b.popped){
      ctx.save(); ctx.translate(b.x,b.y);
      // string
      ctx.strokeStyle='#f1f5f9'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,30*b.sizeRatio); ctx.lineTo(0,80); ctx.stroke();
      // envelope
      const w=50*b.sizeRatio, h=70*b.sizeRatio;
      const grd=ctx.createRadialGradient(-w*0.2,-h*0.2,10,0,0,w*1.2);
      grd.addColorStop(0,'#ffb3b3'); grd.addColorStop(1,'#e11d48');
      ctx.fillStyle=grd; ctx.beginPath(); ctx.ellipse(0,0,w,h,0,0,Math.PI*2); ctx.fill();
      // basket
      ctx.fillStyle='#c8a16b'; ctx.fillRect(-16,80,32,18);
      ctx.restore();
    } else {
      // pop text
      ctx.fillStyle='#fff'; ctx.font='bold 42px system-ui'; ctx.textAlign='center';
      ctx.fillText('POP!', b.x, b.y);
    }

    // Tokens
    tokens.forEach(drawStar);

    // HUD
    const ok=size<1.8, near=size>=1.8 && size<2.15; const clazz= ok? 'good':(near?'warn':'bad');
    setHUD([
      `Score: <strong>${score}</strong>`,
      `Altitude: <strong>${b.altKm.toFixed(1)}</strong> km`,
      `Outside P: <strong>${Pout.toFixed(1)}</strong> kPa`,
      `Balloon size: <strong class="${clazz}">${size.toFixed(2)}√ó</strong>`,
      `Heat: <strong>${(b.heat*100)|0}%</strong>`,
      `Tokens: <strong>${tokens.filter(t=>t.got).length}/3</strong>`
    ]);

    // Win / lose text
    if(tokens.every(t=>t.got)){
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#bbf7d0'; ctx.font='bold 32px system-ui'; ctx.textAlign='center';
      ctx.fillText('Mission Complete! ‚≠ê Great science flying!', W/2, H/2);
    }
    if(b.popped){
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fecaca'; ctx.font='bold 28px system-ui'; ctx.textAlign='center';
      ctx.fillText('Balloon burst! Press Reset to try again.', W/2, H/2+40);
    }
  }

  // ---------- Cabin tick ----------
  function tickCabin(dt){
    time+=dt;
    // Controls: altitude
    if(keys['arrowup']) plane.vy-=15*dt; if(keys['arrowdown']) plane.vy+=15*dt;
    plane.vy=clamp(plane.vy,-20,20); plane.y += plane.vy; plane.vy*=0.985;
    plane.y=clamp(plane.y,80,H-100);
    // Map y to altitude 0..12 km
    const t=clamp((plane.y-80)/(H-180),0,1); plane.altKm= lerp(12,0,t);

    // Dial controls: Q/E coarse, W/S fine
    if(keys['q']) plane.cabinEqKm-=0.8*dt;
    if(keys['e']) plane.cabinEqKm+=0.8*dt;
    if(keys['w']) plane.cabinEqKm-=0.25*dt;
    if(keys['s']) plane.cabinEqKm+=0.25*dt;
    plane.cabinEqKm=clamp(plane.cabinEqKm, 0, plane.altKm);

    const Pout=pKPa(plane.altKm);
    const Pin=pKPa(plane.cabinEqKm);
    const dP=Pin-Pout; const dPpsi=dP*0.1450377377;

    // Safety bands (toy): comfort if Pin>=75 kPa (~8k ft) ; structural safe if dPpsi<=9.0
    const comfy = Pin>=75; const structOK = dPpsi<=9.0; const ok = comfy && structOK;
    if(ok) plane.timeSafe+=dt; else plane.timeUnsafe+=dt;

    // Background
    drawSkyGradient(); drawGround();

    // Plane sprite
    ctx.save(); ctx.translate(plane.x,plane.y);
    ctx.fillStyle='#e5e7eb';
    ctx.beginPath(); ctx.ellipse(0,0,80,26,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#cbd5e1'; ctx.fillRect(-20,8,60,10); // wing
    // windows
    ctx.fillStyle='#38bdf8'; for(let i=0;i<5;i++){ ctx.beginPath(); ctx.arc(-40+i*20,-6,6,0,Math.PI*2); ctx.fill(); }
    ctx.restore();

    // Altitude tape
    ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fillRect(W-90,0,90,H);
    ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.textAlign='right';
    for(let a=0;a<=12;a+=2){ const yy=lerp(H-100,80,a/12); ctx.fillText(a+" km", W-6, yy); ctx.fillRect(W-30,yy,18,1); }

    // HUD
    const cClass=comfy?'good':'bad'; const sClass=structOK?'good':(dPpsi>10?'bad':'warn');
    setHUD([
      `Altitude: <strong>${plane.altKm.toFixed(1)}</strong> km`,
      `Outside P: <strong>${Pout.toFixed(1)}</strong> kPa`,
      `Cabin eq alt: <strong>${plane.cabinEqKm.toFixed(1)}</strong> km`,
      `Cabin P: <strong>${Pin.toFixed(1)}</strong> kPa <span class="${cClass}">(${comfy? 'comfort OK':'low O‚ÇÇ risk'})</span>`,
      `ŒîP: <strong>${dP.toFixed(1)}</strong> kPa <strong>${dPpsi.toFixed(2)}</strong> psi <span class="${sClass}">(${structOK? 'structural OK': (dPpsi>10? 'too high!':'near limit')})</span>`,
      `Safe time: <strong>${plane.timeSafe.toFixed(1)} s</strong>`
    ]);

    // Messages
    if(!comfy || !structOK){
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,40);
      ctx.fillStyle='#fff'; ctx.font='14px system-ui'; ctx.textAlign='center';
      let msg=''; if(!comfy && !structOK) msg='Adjust cabin LOWER (more pressure) and reduce ŒîP by lowering aircraft or raising cabin eq.';
      else if(!comfy) msg='Cabin too thin ‚Äî lower cabin equivalent altitude (Q/W).';
      else msg='ŒîP high ‚Äî reduce by climbing less or raising cabin eq (E/S).';
      ctx.fillText(msg, W/2, 26);
    }
  }

})();
</script>
</body>
</html>
